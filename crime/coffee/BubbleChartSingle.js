// Generated by CoffeeScript 2.2.4
(function() {
  this.BubbleChart = class BubbleChart {
    constructor(id, data, color) {
      this.get_circular_scale_values = this.get_circular_scale_values.bind(this);
      this.scale = this.scale.bind(this);
      this.create_scale = this.create_scale.bind(this);
      // create svg at #vis and then
      // create circle representation for each node
      this.create_vis = this.create_vis.bind(this);
      this.get_bubble = this.get_bubble.bind(this);
      this.create_circles = this.create_circles.bind(this);
      this.update_circles = this.update_circles.bind(this);
      // oneForce set to true means we are re-using the same layout
      // otherwise set to false
      this.force_layout = this.force_layout.bind(this);
      this.plot = this.plot.bind(this);
      // Sets up force layout to display
      // all nodes in one circle.
      this.display = this.display.bind(this);
      // Moves all circles towards the @center
      // of the visualization
      this.move_towards_center = this.move_towards_center.bind(this);
      this.on_tick = this.on_tick.bind(this);
      this.load_overlay = this.load_overlay.bind(this);
      this.set_color_scheme = this.set_color_scheme.bind(this);
      this.show_details = this.show_details.bind(this);
      this.hide_details = this.hide_details.bind(this);
      // need to call this every time we move away
      // from this visual. If we use the same data for several
      // visuals and we move away to fast and force layouts are still happening,
      // weird things may (and will) occur
      this.cleanup = this.cleanup.bind(this);
      // make sure we don't end up with "##id"
      this.id = `#${id.removeLeadHash()}`;
      this.data = data;
      this.width = 940;
      this.height = 700;
      // we may use many force layouts
      // and they need to be cleaned up when the time comes
      this.forces = [];
      // logarithm of 10 used to round things
      // to the closest power of 10
      this.log2_10 = Math.log(10);
      this.log10 = (x) => {
        return Math.floor(Math.log(x) / this.log2_10);
      };
      this.colorScheme = color == null ? "RdGy" : color;
      this.percent_formatter = d3.format(",.2f");
      this.fixed_formatter = d3.format(",d");
      // locations the nodes will move towards
      // depending on which view is currently being
      // used
      this.center = {
        x: this.width / 2,
        y: this.height / 2
      };
      this.xDelta = this.width;
      this.yDelta = this.height;
      // used when setting up force and
      // moving around nodes
      this.layout_gravity = -0.01;
      this.damper = 0.12;
      this.charge = function(d) {
        return -Math.pow(d.radius, 2) / 8;
      };
      this.friction = 0.9;
      // these will be set in create_nodes and create_vis
      this.vis = null;
      this.force = null;
      // use Cynthia Brewer color brewer classes
      this.color_class = (n) => {
        return "q1-6";
      };
      this.max_range = 65;
      this.max_amount = d3.max(this.data, function(d) {
        return d.value;
      });
      this.scale();
      // this interpolation will smoothely transition our colors
      // colros are defined by styles in the form qX-6 (X from 0 to 5)
      // so we can transition them with the animation.
      d3.interpolators.push(function(a, b) {
        var ma, mb, re;
        re = /^q([0-9])+/;
        ma = re.exec(a);
        mb = re.exec(b);
        if ((ma != null) && (mb != null)) {
          a = parseInt(ma[1]);
          b = parseInt(mb[1]) - a;
          return function(t) {
            return `q${Math.round(a + b * t)}-9`;
          };
        }
      });
    }

    get_circular_scale_values() {
      var i, iMin, results;
      i = this.log10(this.max_amount);
      // we only want three powers of ten max for the scale
      iMin = i - 2 > 0 ? i - 2 : 0;
      results = [];
      while (i >= iMin) {
        results.push(Math.pow(10, i--));
      }
      return results;
    }

    scale() {
      return this.radius_scale = d3.scale.pow().exponent(0.5).domain([0, this.max_amount]).range([2, this.max_range]);
    }

    create_scale(anchor) {
      var values;
      values = this.get_circular_scale_values();
      if ((this.bubble_scale == null) || !this.bubble_scale.exists()) {
        return this.bubble_scale = new CircularScale(this.id, "circularScale", "Cirulos por população", this.radius_scale, values, anchor != null ? anchor : {
          x: this.width,
          y: -this.height
        });
      } else {
        return this.bubble_scale.refresh(this.radius_scale, values);
      }
    }

    create_vis() {
      $(this.id).children().remove();
      $(this.id).css("width", `${this.width}px`);
      $(this.id).css("height", `${this.height}px`);
      return this.vis = d3.select(this.id).append("svg").attr("width", this.width).attr("height", this.height).attr("id", "svg_vis").attr("class", this.colorScheme);
    }

    get_bubble(cell, data) {
      return cell.selectAll("circle").data(data, function(d) {
        return d.id;
      });
    }

    create_circles(cell, data) {
      var that;
      that = this;
      return this.get_bubble(cell, data).enter().append("circle").attr("r", 0).attr("class", (d) => {
        return this.color_class(d.group);
      }).attr("stroke-width", 2).attr("stroke", function(d) {
        return d3.rgb($(this).css("fill")).darker();
      }).attr("id", function(d) {
        return `${d.id}`;
      }).on("mouseover", function(d, i) {
        return that.show_details(d, i, this);
      }).on("mouseout", function(d, i) {
        return that.hide_details(d, i, this);
      });
    }

    update_circles(cell, data) {
      return this.get_bubble(cell, data).attr("stroke", function(d) {
        return d3.rgb($(this).css("fill")).darker();
      });
    }

    force_layout(circles, data, size, move, oneForce, param) {
      var force, ref;
      force = d3.layout.force().nodes(data).size(size);
      if ((oneForce != null) && oneForce) {
        if ((ref = this.force) != null) {
          ref.stop();
        }
        this.force = force;
      } else {
        this.forces.push(force);
      }
      return force.gravity(this.layout_gravity).charge(this.charge).friction(this.friction).on("tick", (e) => {
        return this.on_tick(move, e, circles, param);
      });
    }

    plot(cell, data, oneForce) {
      var circles, force;
      circles = this.create_circles(cell, data);
      // Fancy transition to make bubbles appear, ending with the correct radius
      circles.transition().duration(2000).attr("r", function(d) {
        return d.radius;
      });
      force = this.force_layout(circles, data, [this.xDelta, this.yDelta], this.move_towards_center, oneForce);
      return force.start();
    }

    display() {
      return this.plot(this.vis, this.data, true);
    }

    move_towards_center(alpha) {
      return (d) => {
        d.x = d.x + (this.center.x - d.x) * this.damper * alpha;
        return d.y = d.y + (this.center.y - d.y) * this.damper * alpha;
      };
    }

    on_tick(move, e, circles, param) {
      return circles.each(move(e.alpha)).attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      });
    }

    load_overlay(data, i, element) {
      return false;
    }

    set_color_scheme(color) {
      this.colorScheme = color;
      return this.vis = this.vis.attr("class", color);
    }

    show_details(data, i, element) {
      return void 0;
    }

    hide_details(data, i, element) {
      return void 0;
    }

    cleanup() {
      var force, j, len, ref, ref1;
      if ((ref = this.force) != null) {
        ref.stop();
      }
      ref1 = this.forces;
      for (j = 0, len = ref1.length; j < len; j++) {
        force = ref1[j];
        if (force != null) {
          force.stop();
        }
      }
      return void 0;
    }

  };

}).call(this);
