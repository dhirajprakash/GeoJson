// Generated by CoffeeScript 2.2.4
(function() {
  var ref,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  ref = this.AllStates = class AllStates extends this.BubbleChart {
    constructor(id, data, color, domain) {
      var i;
      super(id, data, color);
      this.update_data = this.update_data.bind(this);
      this.create_vis = this.create_vis.bind(this);
      this.show_details = this.show_details.bind(this);
      this.hide_details = this.hide_details.bind(this);
      this.move_arranged = this.move_arranged.bind(this);
      this.move_towards_center = this.move_towards_center.bind(this);
      this.display = this.display.bind(this);
      this.update_display = this.update_display.bind(this);
      this.rearrange = this.rearrange.bind(this);
      // arrange by crime and then invoke a regular layout to create a nice spherical shape
      this.on_tick = this.on_tick.bind(this);
      this.height = 900;
      this.max_range = 90;
      this.scale();
      this.domain = domain != null ? domain : d3.range(100, 1700, 200);
      this.color_class = d3.scale.threshold().domain(this.domain).range((function() {
        var j, results;
        results = [];
        for (i = j = 8; j >= 0; i = --j) {
          results.push(`q${i}-9`);
        }
        return results;
      })());
      this.tips = {};
      // map for sorting bubbles based on their category
      this.map_group = d3.scale.threshold().domain(this.domain).range([4, 3, 2, 1, 0, -1, -2, -3, -4]);
      this.legend_text = () => {
        var e, text;
        text = (function() {
          var j, len, ref1, results;
          ref1 = this.domain;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            e = ref1[j];
            results.push(`< ${e}`);
          }
          return results;
        }).call(this);
        text.push(`${this.domain[this.domain.length - 1]} or more`);
        return text;
      };
      this.crimes = [];
      this.boundingRadius = this.height / 2;
    }

    update_data(set_crime_only) {
      boundMethodCheck(this, ref);
      return this.data.forEach((d) => {
        var crime;
        if (this.crimes.length > 0) {
          d.group = d3.sum((function() {
            var j, len, ref1, results;
            ref1 = this.crimes;
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              crime = ref1[j];
              results.push(d[crime]);
            }
            return results;
          }).call(this)) / d.value * 100000;
        }
        if ((set_crime_only == null) || set_crime_only === false) {
          d.radius = this.radius_scale(d.value);
          d.x = Math.random() * this.width;
          d.y = Math.random() * this.height;
          delete d.px;
          return delete d.py;
        }
      });
    }

    create_vis() {
      boundMethodCheck(this, ref);
      super.create_vis();
      this.tips = {};
      // since we are using a threshold scale, we need to make sure we fall into the bucket
      // we promise to fall into in the legend text
      this.legend = new Legend(this.vis, ((i) => {
        if (i < this.domain.length) {
          return this.color_class(this.domain[i] - 1);
        } else {
          return this.color_class(this.domain[this.domain.length - 1] + 1);
        }
      }), this.legend_text(), 'Crime per 100,000 population', {
        x: 75,
        y: 40
      });
      this.legend.show(true);
      this.create_scale({
        x: this.width,
        y: -this.height + 30
      });
      this.search = new Search(this.id, this, (function(d) {
        return d.name;
      }), (function(data, text) {
        return $.grep(data, function(d) {
          return d.name === text;
        })[0];
      }), {
        x: this.width,
        y: -800
      });
      return this.search.create_search_box();
    }

    show_details(data) {
      var content, crime, tip;
      boundMethodCheck(this, ref);
      content = `Population: ${this.fixed_formatter(data.value)}<br/>Crime: ${this.fixed_formatter(d3.sum((function() {
        var j, len, ref1, results;
        ref1 = this.crimes;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          crime = ref1[j];
          results.push(data[crime]);
        }
        return results;
      }).call(this)))}<br />`;
      content += `Crime per 100,000: ${this.percent_formatter(data.group)}`;
      d3.select(`#${data.id}`).attr("stroke", "black").attr("stroke-width", 4);
      tip = this.tips[data.id];
      if (tip == null) {
        tip = new Opentip(`#${data.id}`, content, data.name, {
          style: "glass",
          fixed: true,
          target: true,
          tipJoint: "left bottom"
        });
        this.tips[data.id] = tip;
      } else {
        tip.setContent(content);
      }
      return tip.show();
    }

    hide_details(data) {
      var ref1;
      boundMethodCheck(this, ref);
      if ((ref1 = this.tips[data.id]) != null) {
        ref1.hide();
      }
      return d3.select(`#${data.id}`).attr("stroke", function(d) {
        return d3.rgb($(this).css("fill")).darker();
      }).attr("stroke-width", 2);
    }

    move_arranged(alpha, slowdown) {
      boundMethodCheck(this, ref);
      return (d) => {
        var targetY;
        targetY = this.center.y - (this.map_group(d.group) / 8) * this.boundingRadius;
        return d.y = d.y + (targetY - d.y + 30) * alpha * alpha * alpha * alpha * 160;
      };
    }

    move_towards_center(alpha, slowdown) {
      boundMethodCheck(this, ref);
      return (d) => {
        d.x = d.x + (this.center.x - d.x) * this.damper * alpha * 0.96;
        return d.y = d.y + (this.center.y - d.y + 50) * this.damper * alpha * 0.96;
      };
    }

    display() {
      boundMethodCheck(this, ref);
      this.update_data();
      return super.display();
    }

    update_display() {
      var circles;
      boundMethodCheck(this, ref);
      this.update_data(true);
      circles = this.get_bubble(this.vis, this.data);
      // chained transitions to update fill color and stroke
      circles.transition().duration(1500).attr("class", (d) => {
        return this.color_class(d.group);
      }).each("end", function(d) {
        return d3.select(this).attr("stroke", d3.rgb($(this).css("fill")).darker());
      });
      return this.rearrange();
    }

    rearrange() {
      var circles, force;
      boundMethodCheck(this, ref);
      // stop all force layouts
      this.cleanup();
      circles = this.get_bubble(this.vis, this.data);
      // this time - slowdown on both layouts
      force = this.force_layout(circles, this.data, [this.xDelta, this.yDelta], (this.arranged ? this.move_arranged : this.move_towards_center), true);
      return force.start();
    }

    on_tick(move, e, circles) {
      boundMethodCheck(this, ref);
      return circles.each(this.move_towards_center(e.alpha)).each(this.move_arranged(e.alpha)).attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      });
    }

  };

}).call(this);
