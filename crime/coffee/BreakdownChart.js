// Generated by CoffeeScript 2.2.4
(function() {
  var ref,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  ref = this.BreakdownChart = class BreakdownChart extends BubbleChart {
    constructor(id, data, color) {
      super(id, data, color);
      this.display = this.display.bind(this);
      this.get_groups = this.get_groups.bind(this);
      this.getX = this.getX.bind(this);
      this.getY = this.getY.bind(this);
      this.update_data = this.update_data.bind(this);
      this.width = 1200;
      // regulates the maximum radius of a bubble
      this.max_range = 40;
      this.scale();
      // speed things up a little
      this.damper = 0.1;
      this.xStart = 50;
      this.yStart = 50;
      this.yDelta = 150;
      this.xDelta = 100;
      //recompute the global center
      this.center = {
        x: this.xDelta / 2,
        y: this.yDelta / 2
      };
      // how many "charts" do we have per line?
      this.groupsPerLine = Math.floor((this.width - this.xStart) / this.xDelta);
    }

    display() {
      var lines, that;
      boundMethodCheck(this, ref);
      that = this;
      this.update_data();
      // figure out container height
      lines = Math.ceil(this.data.length / this.groupsPerLine);
      this.height = lines * this.yDelta + this.yStart + 10;
      $("#vis").css("height", `${Math.max(700, this.height)
      // cf. BubbleChart create_vis(), which sets it to 700px
}px`);
      this.vis.attr("height", this.height);
      this.vis.select("svg").attr("height", this.height);
      //will display groups
      this.groups = this.vis.selectAll("g.cell").data(this.data, function(d) {
        return d.id;
      }).enter().append("g").attr("id", function(d) {
        return d.id;
      }).attr("class", "cell").attr("transform", (d, i) => {
        return `translate(${this.width + this.getX(i)}, ${this.getY(i)})`;
      });
      this.groups.each(function(d) {
        return that.plot(d3.select(this), that.get_group_data(d), false); // false means we are using different force layout for each plot
      });
      this.groups.append("text").attr("x", this.center.x).attr("y", this.yDelta).attr("text-anchor", "middle").text(function(d) {
        return that.get_group_title(d);
      });
      return this.groups.transition().duration(1200).attr("transform", (d, i) => {
        return `translate(${this.getX(i)}, ${this.getY(i)})`;
      });
    }

    get_groups() {
      boundMethodCheck(this, ref);
      return this.vis.selectAll("g.cell").data(this.data, function(d) {
        return d.id;
      });
    }

    getX(i) {
      boundMethodCheck(this, ref);
      return this.xStart + this.xDelta * (i % this.groupsPerLine);
    }

    getY(i) {
      boundMethodCheck(this, ref);
      return this.yStart + this.yDelta * Math.floor(i / this.groupsPerLine);
    }

    update_data() {
      boundMethodCheck(this, ref);
      return this.data.forEach((d) => {
        d.radius = this.radius_scale(d.value);
        d.x = Math.random() * this.xDelta / 2;
        d.y = Math.random() * this.yDelta / 2;
        delete d.px;
        return delete d.py;
      });
    }

  };

}).call(this);
